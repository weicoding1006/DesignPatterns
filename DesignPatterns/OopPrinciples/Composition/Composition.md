# 物件導向設計原則：組合 (Composition)

## 什麼是組合 (Composition)？

**組合 (Composition)** 是一種描述「擁有 (Has-A)」關係的物件導向設計原則。它允許你將多個較小的、功能單一的類別組合成一個更大、更具體、更複雜的類別。

相較於「繼承 (Inheritance)」所描述的「是一個 (Is-A)」關係，組合提供了更高的靈活性與較低的耦合度。這也是設計模式中極為重要的一句話：「**多用組合，少用繼承 (Favor composition over inheritance)**」。

---

## 程式碼範例解析

在目前的範例中，一台車子 (`CompositionCar`) 是由多個零件所組成的。這些零件各自負責特定的功能，而車子則是將它們「組合」起來。

### 1. 定義單一職責的零件 (Components)

我們先定義了車子的各個獨立零件類別，每個零件都有自己的職責與行為：

- **引擎 (`Engine.cs`)**：負責發動 (`Start()`)
- **輪子 (`Wheels.cs`)**：負責轉動 (`Rotate()`)
- **底盤 (`Chassis.cs`)**：負責支撐 (`Support()`)
- **座位 (`Seats.cs`)**：提供乘坐 (`Sit()`)

這些類別都是各自獨立運作的，彼此之間沒有繼承關係，降低了系統的耦合。

### 2. 透過「組合」建立車子 (`Car.cs`)

接下來，我們看看 `CompositionCar` 類別是如何將這些獨立的零件組合起來，形成一個完整的系統：

```csharp
public class CompositionCar{
    // 組合 (Composition)：Car「擁有 (Has-A)」這些零件
    private Chassis chassis = new Chassis();
    private Engine engine = new Engine();
    private Seats seats = new Seats();
    private Wheels wheels = new Wheels();

    public void StartCar()
    {
        // 委派 (Delegation)：將具體任務交給各自負責的零件去執行
        engine.Start();
        wheels.Rotate();
        chassis.Support();
        seats.Sit();
        Console.WriteLine("車子啟動");
    }
}
```

---

## 組合 (Composition) 的優點與重點重點說明

1. **Has-A 關係**：`CompositionCar` **擁有** `Engine`、`Wheels` 等物件。車子「不是」一個引擎（不適用繼承），而是「擁有」一個引擎。
2. **任務委派 (Delegation)**：當呼叫外面提供的 `StartCar()` 方法時，`CompositionCar` 本身並不實作如何讓引擎發動、如何讓輪子轉動的細節。它是將具體的工作委派給它所擁有的物件 (`engine.Start()`, `wheels.Rotate()`) 去執行。這隱藏了實作細節。
3. **更高的靈活性與較低的耦合度**：
   - 假設今天我們想要換一顆不同型號（甚至是不同驅動方式）的引擎，只要它符合引擎的行爲，我們就可以輕鬆替換，不需要修改冗長的繼承體系。
   - 如果我們想要打造不同的載具（例如卡車、飛機），我們也能重複使用（Reuse）這些現成的零件類別，這是繼承難以靈活做到的事。

透過物件的組合，我們的程式碼變得更易於維護、擴充、測試與重複使用。

---

## 繼承 (Inheritance) 與 組合 (Composition) 的選擇時機

在物件導向設計中，我們常常需要在「繼承」與「組合」之間做出選擇。雖然設計原則鼓勵「多用組合，少用繼承」，但這兩種方式各有其適合的場景：

### 什麼時候該使用「組合 (Composition)」？

當你發現物件之間的關係是**「擁有 (Has-A)」或「使用 (Uses-A)」**時，請優先選擇組合。
組合通常能帶來更好的設計彈性：

1. **需要動態改變行為時**：如果你的「車子」在執行期間需要換裝不同的「引擎」（例如從汽油引擎換成電動引擎），組合可以透過替換內部物件輕鬆達成，而繼承的關係在編譯時就已經固定了。
2. **多個類別需要共享相同的功能，但它們不屬於同一個家族時**：例如 `Car` (車子) 和 `Airplane` (飛機) 都需要 `Engine` (引擎)，但它們不應該繼承自同一個「擁有引擎的交通工具」父類別，此時將 `Engine` 抽出來作為元件讓它們各自「組合」是最好的作法。
3. **避免繼承體系過深（階層爆炸）時**：過多的繼承層級會讓程式碼難以閱讀和維護。當子類別只需要父類別的「部分」功能時，使用組合將該部分功能獨立成類別會更乾淨。

### 什麼時候該使用「繼承 (Inheritance)」？

當你非常確定物件之間存在著**明確的「是一個 (Is-A)」**關係，且符合**里氏替換原則 (Liskov Substitution Principle, LSP)** 時，才建議使用繼承。

1. **明確的分支分類**：例如 `Dog` (狗) 是一種 `Animal` (動物)，`Cat` (貓) 也是一種 `Animal`。在任何需要 `Animal` 的地方，換成 `Dog` 或 `Cat` 都應該邏輯正確且不會出錯。
2. **需要大量重複使用且覆寫（Override）父類別行為時**：當子類別與父類別高度相似，且你需要利用多型 (Polymorphism) 在不同子型別中覆寫特定方法時，繼承會是非常方便的工具。
3. **框架或 API 強制要求時**：某些 UI 框架（例如繼承 `Form` 或 `Controller`）會要求你透過繼承特定的基底類別來擴充功能。

### 總結

| 特性 | 組合 (Composition) | 繼承 (Inheritance) |
| :--- | :--- | :--- |
| **關係描述** | **Has-A** (擁有) | **Is-A** (是一個) |
| **設計風格** | 黑箱復用，僅依賴公開介面。 | 白箱復用，子類別依賴父類別內部實作。 |
| **彈性與耦合** | **高彈性、低耦合**，元件可在執行期抽換。 | **低彈性、高耦合**，編譯期即綁定關係。 |
| **何時使用** | **優先考慮**，當需要依賴其他類別的功能時。 | **謹慎使用**，當有明確且純粹的 Is-A 分類，且符合 LSP 時。 |
